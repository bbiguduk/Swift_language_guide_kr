

<!DOCTYPE html>



<head>
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Advanced Operators &mdash; The Swift Programming Language (Swift 5.7)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../_static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../_static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.7</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../">Welcome to Swift</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html">Language Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html">The Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html">Basic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html">Strings and Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html">Collection Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html">Control Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html">Closures</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html">Enumerations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html">Structures and Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html">Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html">Subscripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html">Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html">Deinitialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html">Optional Chaining</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html">Type Casting</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html">Nested Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html">Extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html">Opaque Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html">Automatic Reference Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html">Memory Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Advanced Operators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html">Language Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="https://swift.org/">← Return to Swift.org</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#">Advanced Operators</a><ul>
<li><a class="reference internal" href="#ID29">Bitwise Operators</a><ul>
<li><a class="reference internal" href="#ID30">Bitwise NOT Operator</a></li>
<li><a class="reference internal" href="#ID31">Bitwise AND Operator</a></li>
<li><a class="reference internal" href="#ID32">Bitwise OR Operator</a></li>
<li><a class="reference internal" href="#ID33">Bitwise XOR Operator</a></li>
<li><a class="reference internal" href="#ID34">Bitwise Left and Right Shift Operators</a><ul>
<li><a class="reference internal" href="#ID35">Shifting Behavior for Unsigned Integers</a></li>
<li><a class="reference internal" href="#ID36">Shifting Behavior for Signed Integers</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#ID37">Overflow Operators</a><ul>
<li><a class="reference internal" href="#ID38">Value Overflow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID41">Precedence and Associativity</a></li>
<li><a class="reference internal" href="#ID42">Operator Methods</a><ul>
<li><a class="reference internal" href="#ID43">Prefix and Postfix Operators</a></li>
<li><a class="reference internal" href="#ID44">Compound Assignment Operators</a></li>
<li><a class="reference internal" href="#ID45">Equivalence Operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID46">Custom Operators</a><ul>
<li><a class="reference internal" href="#ID47">Precedence for Custom Infix Operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID630">Result Builders</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="advanced-operators">
<h1>Advanced Operators<a class="headerlink" href="#advanced-operators" title="Permalink to this headline">¶</a></h1>
<p>In addition to the operators described in <a class="reference internal" href="BasicOperators.html"><span class="doc">Basic Operators</span></a>, Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</p>
<p>Unlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default. Overflow behavior is trapped and reported as an error. To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>). All of these overflow operators begin with an ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>).</p>
<p>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.</p>
<p>You’re not limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</p>
<div class="section" id="ID29">
<h2>Bitwise Operators<a class="headerlink" href="#ID29" title="Permalink to this headline">¶</a></h2>
<p><em>Bitwise operators</em> enable you to manipulate the individual raw data bits within a data structure. They’re often used in low-level programming, such as graphics programming and device driver creation. Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.</p>
<p>Swift supports all of the bitwise operators found in C, as described below.</p>
<div class="section" id="ID30">
<h3>Bitwise NOT Operator<a class="headerlink" href="#ID30" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise NOT operator</em> (<code class="docutils literal notranslate"><span class="pre">~</span></code>) inverts all bits in a number:</p>
<img alt="../_images/bitwiseNOT_2x.png" class="align-center" src="../_images/bitwiseNOT_2x.png" style="width: 330.0px;" />
<p>The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">initialBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00001111</span>
</li><li><span class="k">let</span> <span class="nv">invertedBits</span> = ~<span class="nv">initialBits</span>  <span class="c">// equals 11110000</span>
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">UInt8</span></code> integers have eight bits and can store any value between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">255</span></code>. This example initializes a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> integer with the binary value <code class="docutils literal notranslate"><span class="pre">00001111</span></code>, which has its first four bits set to <code class="docutils literal notranslate"><span class="pre">0</span></code>, and its second four bits set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. This is equivalent to a decimal value of <code class="docutils literal notranslate"><span class="pre">15</span></code>.</p>
<p>The bitwise NOT operator is then used to create a new constant called <code class="docutils literal notranslate"><span class="pre">invertedBits</span></code>, which is equal to <code class="docutils literal notranslate"><span class="pre">initialBits</span></code>, but with all of the bits inverted. Zeros become ones, and ones become zeros. The value of <code class="docutils literal notranslate"><span class="pre">invertedBits</span></code> is <code class="docutils literal notranslate"><span class="pre">11110000</span></code>, which is equal to an unsigned decimal value of <code class="docutils literal notranslate"><span class="pre">240</span></code>.</p>
</div>
<div class="section" id="ID31">
<h3>Bitwise AND Operator<a class="headerlink" href="#ID31" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise AND operator</em> (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) combines the bits of two numbers. It returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> only if the bits were equal to <code class="docutils literal notranslate"><span class="pre">1</span></code> in <em>both</em> input numbers:</p>
<img alt="../_images/bitwiseAND_2x.png" class="align-center" src="../_images/bitwiseAND_2x.png" style="width: 330.0px;" />
<p>In the example below, the values of <code class="docutils literal notranslate"><span class="pre">firstSixBits</span></code> and <code class="docutils literal notranslate"><span class="pre">lastSixBits</span></code> both have four middle bits equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The bitwise AND operator combines them to make the number <code class="docutils literal notranslate"><span class="pre">00111100</span></code>, which is equal to an unsigned decimal value of <code class="docutils literal notranslate"><span class="pre">60</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">firstSixBits</span>: <span class="nc">UInt8</span> = <span class="m">0b11111100</span>
</li><li><span class="k">let</span> <span class="nv">lastSixBits</span>: <span class="nc">UInt8</span>  = <span class="m">0b00111111</span>
</li><li><span class="k">let</span> <span class="nv">middleFourBits</span> = <span class="nv">firstSixBits</span> &amp; <span class="nv">lastSixBits</span>  <span class="c">// equals 00111100</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID32">
<h3>Bitwise OR Operator<a class="headerlink" href="#ID32" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise OR operator</em> (<code class="docutils literal notranslate"><span class="pre">|</span></code>) compares the bits of two numbers. The operator returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the bits are equal to <code class="docutils literal notranslate"><span class="pre">1</span></code> in <em>either</em> input number:</p>
<img alt="../_images/bitwiseOR_2x.png" class="align-center" src="../_images/bitwiseOR_2x.png" style="width: 330.0px;" />
<p>In the example below, the values of <code class="docutils literal notranslate"><span class="pre">someBits</span></code> and <code class="docutils literal notranslate"><span class="pre">moreBits</span></code> have different bits set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The bitwise OR operator combines them to make the number <code class="docutils literal notranslate"><span class="pre">11111110</span></code>, which equals an unsigned decimal of <code class="docutils literal notranslate"><span class="pre">254</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someBits</span>: <span class="nc">UInt8</span> = <span class="m">0b10110010</span>
</li><li><span class="k">let</span> <span class="nv">moreBits</span>: <span class="nc">UInt8</span> = <span class="m">0b01011110</span>
</li><li><span class="k">let</span> <span class="nv">combinedbits</span> = <span class="nv">someBits</span> | <span class="nv">moreBits</span>  <span class="c">// equals 11111110</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID33">
<h3>Bitwise XOR Operator<a class="headerlink" href="#ID33" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise XOR operator</em>, or “exclusive OR operator” (<code class="docutils literal notranslate"><span class="pre">^</span></code>), compares the bits of two numbers. The operator returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> where the input bits are different and are set to <code class="docutils literal notranslate"><span class="pre">0</span></code> where the input bits are the same:</p>
<img alt="../_images/bitwiseXOR_2x.png" class="align-center" src="../_images/bitwiseXOR_2x.png" style="width: 330.0px;" />
<p>In the example below, the values of <code class="docutils literal notranslate"><span class="pre">firstBits</span></code> and <code class="docutils literal notranslate"><span class="pre">otherBits</span></code> each have a bit set to <code class="docutils literal notranslate"><span class="pre">1</span></code> in a location that the other does not. The bitwise XOR operator sets both of these bits to <code class="docutils literal notranslate"><span class="pre">1</span></code> in its output value. All of the other bits in <code class="docutils literal notranslate"><span class="pre">firstBits</span></code> and <code class="docutils literal notranslate"><span class="pre">otherBits</span></code> match and are set to <code class="docutils literal notranslate"><span class="pre">0</span></code> in the output value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">firstBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00010100</span>
</li><li><span class="k">let</span> <span class="nv">otherBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00000101</span>
</li><li><span class="k">let</span> <span class="nv">outputBits</span> = <span class="nv">firstBits</span> ^ <span class="nv">otherBits</span>  <span class="c">// equals 00010001</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID34">
<h3>Bitwise Left and Right Shift Operators<a class="headerlink" href="#ID34" title="Permalink to this headline">¶</a></h3>
<p>The <em>bitwise left shift operator</em> (<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>) and <em>bitwise right shift operator</em> (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.</p>
<p>Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two. Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.</p>
<div class="section" id="ID35">
<h4>Shifting Behavior for Unsigned Integers<a class="headerlink" href="#ID35" title="Permalink to this headline">¶</a></h4>
<p>The bit-shifting behavior for unsigned integers is as follows:</p>
<ol class="arabic simple">
<li><p>Existing bits are moved to the left or right by the requested number of places.</p></li>
<li><p>Any bits that are moved beyond the bounds of the integer’s storage are discarded.</p></li>
<li><p>Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.</p></li>
</ol>
<p>This approach is known as a <em>logical shift</em>.</p>
<p>The illustration below shows the results of <code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code> (which is <code class="docutils literal notranslate"><span class="pre">11111111</span></code> shifted to the left by <code class="docutils literal notranslate"><span class="pre">1</span></code> place), and <code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code> (which is <code class="docutils literal notranslate"><span class="pre">11111111</span></code> shifted to the right by <code class="docutils literal notranslate"><span class="pre">1</span></code> place). Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:</p>
<img alt="../_images/bitshiftUnsigned_2x.png" class="align-center" src="../_images/bitshiftUnsigned_2x.png" style="width: 541.0px;" />
<p>Here’s how bit shifting looks in Swift code:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">shiftBits</span>: <span class="nc">UInt8</span> = <span class="m">4</span>   <span class="c">// 00000100 in binary</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">1</span>             <span class="c">// 00001000</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">2</span>             <span class="c">// 00010000</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">5</span>             <span class="c">// 10000000</span>
</li><li><span class="nv">shiftBits</span> &lt;&lt; <span class="m">6</span>             <span class="c">// 00000000</span>
</li><li><span class="nv">shiftBits</span> &gt;&gt; <span class="m">2</span>             <span class="c">// 00000001</span>
</li></ol></div></div></div>
<p>You can use bit shifting to encode and decode values within other data types:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">pink</span>: <span class="nc">UInt32</span> = <span class="m">0xCC6699</span>
</li><li><span class="k">let</span> <span class="nv">redComponent</span> = (<span class="nv">pink</span> &amp; <span class="m">0xFF0000</span>) &gt;&gt; <span class="m">16</span>    <span class="c">// redComponent is 0xCC, or 204</span>
</li><li><span class="k">let</span> <span class="nv">greenComponent</span> = (<span class="nv">pink</span> &amp; <span class="m">0x00FF00</span>) &gt;&gt; <span class="m">8</span>   <span class="c">// greenComponent is 0x66, or 102</span>
</li><li><span class="k">let</span> <span class="nv">blueComponent</span> = <span class="nv">pink</span> &amp; <span class="m">0x0000FF</span>           <span class="c">// blueComponent is 0x99, or 153</span>
</li></ol></div></div></div>
<p>This example uses a <code class="docutils literal notranslate"><span class="pre">UInt32</span></code> constant called <code class="docutils literal notranslate"><span class="pre">pink</span></code> to store a Cascading Style Sheets color value for the color pink. The CSS color value <code class="docutils literal notranslate"><span class="pre">#CC6699</span></code> is written as <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> in Swift’s hexadecimal number representation. This color is then decomposed into its red (<code class="docutils literal notranslate"><span class="pre">CC</span></code>), green (<code class="docutils literal notranslate"><span class="pre">66</span></code>), and blue (<code class="docutils literal notranslate"><span class="pre">99</span></code>) components by the bitwise AND operator (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) and the bitwise right shift operator (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>).</p>
<p>The red component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code>. The zeros in <code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code> effectively “mask” the second and third bytes of <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>, causing the <code class="docutils literal notranslate"><span class="pre">6699</span></code> to be ignored and leaving <code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code> as the result.</p>
<p>This number is then shifted 16 places to the right (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">16</span></code>). Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert <code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code> into <code class="docutils literal notranslate"><span class="pre">0x0000CC</span></code>. This is the same as <code class="docutils literal notranslate"><span class="pre">0xCC</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">204</span></code>.</p>
<p>Similarly, the green component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0x00FF00</span></code>, which gives an output value of <code class="docutils literal notranslate"><span class="pre">0x006600</span></code>. This output value is then shifted eight places to the right, giving a value of <code class="docutils literal notranslate"><span class="pre">0x66</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">102</span></code>.</p>
<p>Finally, the blue component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0x0000FF</span></code>, which gives an output value of <code class="docutils literal notranslate"><span class="pre">0x000099</span></code>. Because <code class="docutils literal notranslate"><span class="pre">0x000099</span></code> already equals <code class="docutils literal notranslate"><span class="pre">0x99</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">153</span></code>, this value is used without shifting it to the right,</p>
</div>
<div class="section" id="ID36">
<h4>Shifting Behavior for Signed Integers<a class="headerlink" href="#ID36" title="Permalink to this headline">¶</a></h4>
<p>The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary. (The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)</p>
<p>Signed integers use their first bit (known as the <em>sign bit</em>) to indicate whether the integer is positive or negative. A sign bit of <code class="docutils literal notranslate"><span class="pre">0</span></code> means positive, and a sign bit of <code class="docutils literal notranslate"><span class="pre">1</span></code> means negative.</p>
<p>The remaining bits (known as the <em>value bits</em>) store the actual value. Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from <code class="docutils literal notranslate"><span class="pre">0</span></code>. Here’s how the bits inside an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> look for the number <code class="docutils literal notranslate"><span class="pre">4</span></code>:</p>
<img alt="../_images/bitshiftSignedFour_2x.png" class="align-center" src="../_images/bitshiftSignedFour_2x.png" style="width: 275.0px;" />
<p>The sign bit is <code class="docutils literal notranslate"><span class="pre">0</span></code> (meaning “positive”), and the seven value bits are just the number <code class="docutils literal notranslate"><span class="pre">4</span></code>, written in binary notation.</p>
<p>Negative numbers, however, are stored differently. They’re stored by subtracting their absolute value from <code class="docutils literal notranslate"><span class="pre">2</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">n</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of value bits. An eight-bit number has seven value bits, so this means <code class="docutils literal notranslate"><span class="pre">2</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">7</span></code>, or <code class="docutils literal notranslate"><span class="pre">128</span></code>.</p>
<p>Here’s how the bits inside an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> look for the number <code class="docutils literal notranslate"><span class="pre">-4</span></code>:</p>
<img alt="../_images/bitshiftSignedMinusFour_2x.png" class="align-center" src="../_images/bitshiftSignedMinusFour_2x.png" style="width: 280.0px;" />
<p>This time, the sign bit is <code class="docutils literal notranslate"><span class="pre">1</span></code> (meaning “negative”), and the seven value bits have a binary value of <code class="docutils literal notranslate"><span class="pre">124</span></code> (which is <code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">-</span> <span class="pre">4</span></code>):</p>
<img alt="../_images/bitshiftSignedMinusFourValue_2x.png" class="align-center" src="../_images/bitshiftSignedMinusFourValue_2x.png" style="width: 252.0px;" />
<p>This encoding for negative numbers is known as a <em>two’s complement</em> representation. It may seem an unusual way to represent negative numbers, but it has several advantages.</p>
<p>First, you can add <code class="docutils literal notranslate"><span class="pre">-1</span></code> to <code class="docutils literal notranslate"><span class="pre">-4</span></code>, simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:</p>
<img alt="../_images/bitshiftSignedAddition_2x.png" class="align-center" src="../_images/bitshiftSignedAddition_2x.png" style="width: 334.0px;" />
<p>Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right. To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the <em>sign bit</em>, rather than with a zero.</p>
<img alt="../_images/bitshiftSigned_2x.png" class="align-center" src="../_images/bitshiftSigned_2x.png" style="width: 541.0px;" />
<p>This action ensures that signed integers have the same sign after they’re shifted to the right, and is known as an <em>arithmetic shift</em>.</p>
<p>Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero. Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.</p>
</div>
</div>
</div>
<div class="section" id="ID37">
<h2>Overflow Operators<a class="headerlink" href="#ID37" title="Permalink to this headline">¶</a></h2>
<p>If you try to insert a number into an integer constant or variable that can’t hold that value, by default Swift reports an error rather than allowing an invalid value to be created. This behavior gives extra safety when you work with numbers that are too large or too small.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">Int16</span></code> integer type can hold any signed integer between <code class="docutils literal notranslate"><span class="pre">-32768</span></code> and <code class="docutils literal notranslate"><span class="pre">32767</span></code>. Trying to set an <code class="docutils literal notranslate"><span class="pre">Int16</span></code> constant or variable to a number outside of this range causes an error:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">potentialOverflow</span> = <span class="nv">Int16</span>.<span class="nv">max</span>
</li><li><span class="c">// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</span>
</li><li><span class="nv">potentialOverflow</span> += <span class="m">1</span>
</li><li><span class="c">// this causes an error</span>
</li></ol></div></div></div>
<p>Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.</p>
<p>However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error. Swift provides three arithmetic <em>overflow operators</em> that opt in to the overflow behavior for integer calculations. These operators all begin with an ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>):</p>
<ul class="simple">
<li><p>Overflow addition (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>)</p></li>
<li><p>Overflow subtraction (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>)</p></li>
<li><p>Overflow multiplication (<code class="docutils literal notranslate"><span class="pre">&amp;*</span></code>)</p></li>
</ul>
<div class="section" id="ID38">
<h3>Value Overflow<a class="headerlink" href="#ID38" title="Permalink to this headline">¶</a></h3>
<p>Numbers can overflow in both the positive and negative direction.</p>
<p>Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">unsignedOverflow</span> = <span class="nv">UInt8</span>.<span class="nv">max</span>
</li><li><span class="c">// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</span>
</li><li><span class="nv">unsignedOverflow</span> = <span class="nv">unsignedOverflow</span> &amp;+ <span class="m">1</span>
</li><li><span class="c">// unsignedOverflow is now equal to 0</span>
</li></ol></div></div></div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">unsignedOverflow</span></code> is initialized with the maximum value a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold (<code class="docutils literal notranslate"><span class="pre">255</span></code>, or <code class="docutils literal notranslate"><span class="pre">11111111</span></code> in binary). It’s then incremented by <code class="docutils literal notranslate"><span class="pre">1</span></code> using the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>). This pushes its binary representation just over the size that a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold, causing it to overflow beyond its bounds, as shown in the diagram below. The value that remains within the bounds of the <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> after the overflow addition is <code class="docutils literal notranslate"><span class="pre">00000000</span></code>, or zero.</p>
<img alt="../_images/overflowAddition_2x.png" class="align-center" src="../_images/overflowAddition_2x.png" style="width: 242.5px;" />
<p>Something similar happens when an unsigned integer is allowed to overflow in the negative direction. Here’s an example using the overflow subtraction operator (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">unsignedOverflow</span> = <span class="nv">UInt8</span>.<span class="nv">min</span>
</li><li><span class="c">// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</span>
</li><li><span class="nv">unsignedOverflow</span> = <span class="nv">unsignedOverflow</span> &amp;- <span class="m">1</span>
</li><li><span class="c">// unsignedOverflow is now equal to 255</span>
</li></ol></div></div></div>
<p>The minimum value that a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold is zero, or <code class="docutils literal notranslate"><span class="pre">00000000</span></code> in binary. If you subtract <code class="docutils literal notranslate"><span class="pre">1</span></code> from <code class="docutils literal notranslate"><span class="pre">00000000</span></code> using the overflow subtraction operator (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>), the number will overflow and wrap around to <code class="docutils literal notranslate"><span class="pre">11111111</span></code>, or <code class="docutils literal notranslate"><span class="pre">255</span></code> in decimal.</p>
<img alt="../_images/overflowUnsignedSubtraction_2x.png" class="align-center" src="../_images/overflowUnsignedSubtraction_2x.png" style="width: 307.0px;" />
<p>Overflow also occurs for signed integers. All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in <a class="reference internal" href="#ID34"><span class="std std-ref">Bitwise Left and Right Shift Operators</span></a>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">signedOverflow</span> = <span class="nv">Int8</span>.<span class="nv">min</span>
</li><li><span class="c">// signedOverflow equals -128, which is the minimum value an Int8 can hold</span>
</li><li><span class="nv">signedOverflow</span> = <span class="nv">signedOverflow</span> &amp;- <span class="m">1</span>
</li><li><span class="c">// signedOverflow is now equal to 127</span>
</li></ol></div></div></div>
<p>The minimum value that an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> can hold is <code class="docutils literal notranslate"><span class="pre">-128</span></code>, or <code class="docutils literal notranslate"><span class="pre">10000000</span></code> in binary. Subtracting <code class="docutils literal notranslate"><span class="pre">1</span></code> from this binary number with the overflow operator gives a binary value of <code class="docutils literal notranslate"><span class="pre">01111111</span></code>, which toggles the sign bit and gives positive <code class="docutils literal notranslate"><span class="pre">127</span></code>, the maximum positive value that an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> can hold.</p>
<img alt="../_images/overflowSignedSubtraction_2x.png" class="align-center" src="../_images/overflowSignedSubtraction_2x.png" style="width: 311.0px;" />
<p>For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.</p>
</div>
</div>
<div class="section" id="ID41">
<h2>Precedence and Associativity<a class="headerlink" href="#ID41" title="Permalink to this headline">¶</a></h2>
<p>Operator <em>precedence</em> gives some operators higher priority than others; these operators are applied first.</p>
<p>Operator <em>associativity</em> defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right. Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”</p>
<p>It’s important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated. For example, operator precedence explains why the following expression equals <code class="docutils literal notranslate"><span class="pre">17</span></code>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + <span class="m">3</span> % <span class="m">4</span> * <span class="m">5</span>
</li><li><span class="c">// this equals 17</span>
</li></ol></div></div></div>
<p>If you read strictly from left to right, you might expect the expression to be calculated as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> plus <code class="docutils literal notranslate"><span class="pre">3</span></code> equals <code class="docutils literal notranslate"><span class="pre">5</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">5</span></code> remainder <code class="docutils literal notranslate"><span class="pre">4</span></code> equals <code class="docutils literal notranslate"><span class="pre">1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> times <code class="docutils literal notranslate"><span class="pre">5</span></code> equals <code class="docutils literal notranslate"><span class="pre">5</span></code></p></li>
</ul>
<p>However, the actual answer is <code class="docutils literal notranslate"><span class="pre">17</span></code>, not <code class="docutils literal notranslate"><span class="pre">5</span></code>. Higher-precedence operators are evaluated before lower-precedence ones. In Swift, as in C, the remainder operator (<code class="docutils literal notranslate"><span class="pre">%</span></code>) and the multiplication operator (<code class="docutils literal notranslate"><span class="pre">*</span></code>) have a higher precedence than the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>). As a result, they’re both evaluated before the addition is considered.</p>
<p>However, remainder and multiplication have the <em>same</em> precedence as each other. To work out the exact evaluation order to use, you also need to consider their associativity. Remainder and multiplication both associate with the expression to their left. Think of this as adding implicit parentheses around these parts of the expression, starting from their left:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + ((<span class="m">3</span> % <span class="m">4</span>) * <span class="m">5</span>)
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">%</span> <span class="pre">4)</span></code> is <code class="docutils literal notranslate"><span class="pre">3</span></code>, so this is equivalent to:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + (<span class="m">3</span> * <span class="m">5</span>)
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">*</span> <span class="pre">5)</span></code> is <code class="docutils literal notranslate"><span class="pre">15</span></code>, so this is equivalent to:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">2</span> + <span class="m">15</span>
</li></ol></div></div></div>
<p>This calculation yields the final answer of <code class="docutils literal notranslate"><span class="pre">17</span></code>.</p>
<p>For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C. However, this means that they aren’t exactly the same as in C-based languages. Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.</p>
</div>
</div>
<div class="section" id="ID42">
<h2>Operator Methods<a class="headerlink" href="#ID42" title="Permalink to this headline">¶</a></h2>
<p>Classes and structures can provide their own implementations of existing operators. This is known as <em>overloading</em> the existing operators.</p>
<p>The example below shows how to implement the arithmetic addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) for a custom structure. The arithmetic addition operator is a binary operator because it operates on two targets and it’s an infix operator because it appears between those two targets.</p>
<p>The example defines a <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure for a two-dimensional position vector <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>, followed by a definition of an <em>operator method</em> to add together instances of the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Vector2D</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> + (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li>        <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="nv">left</span>.<span class="nv">x</span> + <span class="nv">right</span>.<span class="nv">x</span>, <span class="nv">y</span>: <span class="nv">left</span>.<span class="nv">y</span> + <span class="nv">right</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The operator method is defined as a type method on <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>, with a method name that matches the operator to be overloaded (<code class="docutils literal notranslate"><span class="pre">+</span></code>). Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> rather than in the main structure declaration of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>. Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> and returns a single output value, also of type <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>.</p>
<p>In this implementation, the input parameters are named <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> to represent the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances that will be on the left side and right side of the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator. The method returns a new <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instance, whose <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties are initialized with the sum of the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties from the two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances that are added together.</p>
<p>The type method can be used as an infix operator between existing <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">vector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">1.0</span>)
</li><li><span class="k">let</span> <span class="nv">anotherVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">combinedVector</span> = <span class="nv">vector</span> + <span class="nv">anotherVector</span>
</li><li><span class="c">// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span>
</li></ol></div></div></div>
<p>This example adds together the vectors <code class="docutils literal notranslate"><span class="pre">(3.0,</span> <span class="pre">1.0)</span></code> and <code class="docutils literal notranslate"><span class="pre">(2.0,</span> <span class="pre">4.0)</span></code> to make the vector <code class="docutils literal notranslate"><span class="pre">(5.0,</span> <span class="pre">5.0)</span></code>, as illustrated below.</p>
<img alt="../_images/vectorAddition_2x.png" class="align-center" src="../_images/vectorAddition_2x.png" style="width: 477.0px;" />
<div class="section" id="ID43">
<h3>Prefix and Postfix Operators<a class="headerlink" href="#ID43" title="Permalink to this headline">¶</a></h3>
<p>The example shown above demonstrates a custom implementation of a binary infix operator. Classes and structures can also provide implementations of the standard <em>unary operators</em>. Unary operators operate on a single target. They’re <em>prefix</em> if they precede their target (such as <code class="docutils literal notranslate"><span class="pre">-a</span></code>) and <em>postfix</em> operators if they follow their target (such as <code class="docutils literal notranslate"><span class="pre">b!</span></code>).</p>
<p>You implement a prefix or postfix unary operator by writing the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> modifier before the <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword when declaring the operator method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li>    <span class="k">static</span> <span class="k">prefix</span> <span class="k">func</span> - (<span class="nv">vector</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li>        <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: -<span class="nv">vector</span>.<span class="nv">x</span>, <span class="nv">y</span>: -<span class="nv">vector</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The example above implements the unary minus operator (<code class="docutils literal notranslate"><span class="pre">-a</span></code>) for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances. The unary minus operator is a prefix operator, and so this method has to be qualified with the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> modifier.</p>
<p>For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa. The corresponding implementation for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances performs this operation on both the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">positive</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">negative</span> = -<span class="nv">positive</span>
</li><li><span class="c">// negative is a Vector2D instance with values of (-3.0, -4.0)</span>
</li><li><span class="k">let</span> <span class="nv">alsoPositive</span> = -<span class="nv">negative</span>
</li><li><span class="c">// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID44">
<h3>Compound Assignment Operators<a class="headerlink" href="#ID44" title="Permalink to this headline">¶</a></h3>
<p><em>Compound assignment operators</em> combine assignment (<code class="docutils literal notranslate"><span class="pre">=</span></code>) with another operation. For example, the addition assignment operator (<code class="docutils literal notranslate"><span class="pre">+=</span></code>) combines addition and assignment into a single operation. You mark a compound assignment operator’s left input parameter type as <code class="docutils literal notranslate"><span class="pre">inout</span></code>, because the parameter’s value will be modified directly from within the operator method.</p>
<p>The example below implements an addition assignment operator method for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> += (<span class="nv">left</span>: <span class="k">inout</span> <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) {
</li><li>        <span class="nv">left</span> = <span class="nv">left</span> + <span class="nv">right</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Because an addition operator was defined earlier, you don’t need to reimplement the addition process here. Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">original</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>)
</li><li><span class="k">let</span> <span class="nv">vectorToAdd</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="nv">original</span> += <span class="nv">vectorToAdd</span>
</li><li><span class="c">// original now has values of (4.0, 6.0)</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It isn’t possible to overload the default assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></code>) can’t be overloaded.</p>
</div>
</div>
<div class="section" id="ID45">
<h3>Equivalence Operators<a class="headerlink" href="#ID45" title="Permalink to this headline">¶</a></h3>
<p>By default, custom classes and structures don’t have an implementation of the <em>equivalence operators</em>, known as the <em>equal to</em> operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) and <em>not equal to</em> operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>). You usually implement the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator, and use the standard library’s default implementation of the <code class="docutils literal notranslate"><span class="pre">!=</span></code> operator that negates the result of the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator. There are two ways to implement the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator: You can implement it yourself, or for many types, you can ask Swift to synthesize an implementation for you. In both cases, you add conformance to the standard library’s <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol.</p>
<p>You provide an implementation of the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator in the same way as you implement other infix operators:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span>: <span class="nc">Equatable</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> == (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Bool</span> {
</li><li>        <span class="k">return</span> (<span class="nv">left</span>.<span class="nv">x</span> == <span class="nv">right</span>.<span class="nv">x</span>) &amp;&amp; (<span class="nv">left</span>.<span class="nv">y</span> == <span class="nv">right</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The example above implements an <code class="docutils literal notranslate"><span class="pre">==</span></code> operator to check whether two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances have equivalent values. In the context of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>, it makes sense to consider “equal” as meaning “both instances have the same <code class="docutils literal notranslate"><span class="pre">x</span></code> values and <code class="docutils literal notranslate"><span class="pre">y</span></code> values”, and so this is the logic used by the operator implementation.</p>
<p>You can now use this operator to check whether two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">twoThree</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="k">let</span> <span class="nv">anotherTwoThree</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="k">if</span> <span class="nv">twoThree</span> == <span class="nv">anotherTwoThree</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;These two vectors are equivalent.&quot;</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;These two vectors are equivalent.&quot;</span>
</li></ol></div></div></div>
<p>In many simple cases, you can ask Swift to provide synthesized implementations of the equivalence operators for you, as described in <a class="reference internal" href="Protocols.html#ID627"><span class="std std-ref">Adopting a Protocol Using a Synthesized Implementation</span></a>.</p>
</div>
</div>
<div class="section" id="ID46">
<h2>Custom Operators<a class="headerlink" href="#ID46" title="Permalink to this headline">¶</a></h2>
<p>You can declare and implement your own <em>custom operators</em> in addition to the standard operators provided by Swift. For a list of characters that can be used to define custom operators, see <a class="reference internal" href="../ReferenceManual/LexicalStructure.html#ID418"><span class="std std-ref">Operators</span></a>.</p>
<p>New operators are declared at a global level using the <code class="docutils literal notranslate"><span class="pre">operator</span></code> keyword, and are marked with the <code class="docutils literal notranslate"><span class="pre">prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">infix</span></code> or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> modifiers:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">prefix</span> <span class="k">operator</span> +++
</li></ol></div></div></div>
<p>The example above defines a new prefix operator called <code class="docutils literal notranslate"><span class="pre">+++</span></code>. This operator doesn’t have an existing meaning in Swift, and so it’s given its own custom meaning below in the specific context of working with <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances. For the purposes of this example, <code class="docutils literal notranslate"><span class="pre">+++</span></code> is treated as a new “prefix doubling” operator. It doubles the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values of a <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instance, by adding the vector to itself with the addition assignment operator defined earlier. To implement the <code class="docutils literal notranslate"><span class="pre">+++</span></code> operator, you add a type method called <code class="docutils literal notranslate"><span class="pre">+++</span></code> to <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> as follows:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li>    <span class="k">static</span> <span class="k">prefix</span> <span class="k">func</span> +++ (<span class="nv">vector</span>: <span class="k">inout</span> <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li>        <span class="nv">vector</span> += <span class="nv">vector</span>
</li><li>        <span class="k">return</span> <span class="nv">vector</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">toBeDoubled</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">afterDoubling</span> = +++<span class="nv">toBeDoubled</span>
</li><li><span class="c">// toBeDoubled now has values of (2.0, 8.0)</span>
</li><li><span class="c">// afterDoubling also has values of (2.0, 8.0)</span>
</li></ol></div></div></div>
<div class="section" id="ID47">
<h3>Precedence for Custom Infix Operators<a class="headerlink" href="#ID47" title="Permalink to this headline">¶</a></h3>
<p>Custom infix operators each belong to a precedence group. A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity. See <a class="reference internal" href="#ID41"><span class="std std-ref">Precedence and Associativity</span></a> for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators.</p>
<p>A custom infix operator that isn’t explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.</p>
<p>The following example defines a new custom infix operator called <code class="docutils literal notranslate"><span class="pre">+-</span></code>, which belongs to the precedence group <code class="docutils literal notranslate"><span class="pre">AdditionPrecedence</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">infix</span> <span class="k">operator</span> +-: <span class="nv">AdditionPrecedence</span>
</li><li><span class="k">extension</span> <span class="nc">Vector2D</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> +- (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li><li>        <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="nv">left</span>.<span class="nv">x</span> + <span class="nv">right</span>.<span class="nv">x</span>, <span class="nv">y</span>: <span class="nv">left</span>.<span class="nv">y</span> - <span class="nv">right</span>.<span class="nv">y</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">firstVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>)
</li><li><span class="k">let</span> <span class="nv">secondVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li><li><span class="k">let</span> <span class="nv">plusMinusVector</span> = <span class="nv">firstVector</span> +- <span class="nv">secondVector</span>
</li><li><span class="c">// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span>
</li></ol></div></div></div>
<p>This operator adds together the <code class="docutils literal notranslate"><span class="pre">x</span></code> values of two vectors, and subtracts the <code class="docutils literal notranslate"><span class="pre">y</span></code> value of the second vector from the first. Because it’s in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code>. For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>. For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID380"><span class="std std-ref">Operator Declaration</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You don’t specify a precedence when defining a prefix or postfix operator. However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.</p>
</div>
</div>
</div>
<div class="section" id="ID630">
<h2>Result Builders<a class="headerlink" href="#ID630" title="Permalink to this headline">¶</a></h2>
<p>A <em>result builder</em> is a type you define that adds syntax for creating nested data, like a list or tree, in a natural, declarative way. The code that uses the result builder can include ordinary Swift syntax, like <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code>, to handle conditional or repeated pieces of data.</p>
<p>The code below defines a few types for drawing on a single line using stars and text.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Drawable</span> {
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Line</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">elements</span>: [<span class="nc">Drawable</span>]
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="nv">elements</span>.<span class="nv">map</span> { <span class="nv">$0</span>.<span class="nv">draw</span>() }.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">&quot;&quot;</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Text</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">content</span> = <span class="nv">content</span> }
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span> }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Space</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="s">&quot; &quot;</span> }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Stars</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">length</span>: <span class="nc">Int</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">String</span>(<span class="nv">repeating</span>: <span class="s">&quot;*&quot;</span>, <span class="nv">count</span>: <span class="nv">length</span>) }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">AllCaps</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">Drawable</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span>.<span class="nv">draw</span>().<span class="nv">uppercased</span>() }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Drawable</span></code> protocol defines the requirement for something that can be drawn, like a line or shape: The type must implement a <code class="docutils literal notranslate"><span class="pre">draw()</span></code> method. The <code class="docutils literal notranslate"><span class="pre">Line</span></code> structure represents a single-line drawing, and it serves the top-level container for most drawings. To draw a <code class="docutils literal notranslate"><span class="pre">Line</span></code>, the structure calls <code class="docutils literal notranslate"><span class="pre">draw()</span></code> on each of the line’s components, and then concatenates the resulting strings into a single string. The <code class="docutils literal notranslate"><span class="pre">Text</span></code> structure wraps a string to make it part of a drawing. The <code class="docutils literal notranslate"><span class="pre">AllCaps</span></code> structure wraps and modifies another drawing, converting any text in the drawing to uppercase.</p>
<p>It’s possible to make a drawing with these types by calling their initializers:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>? = <span class="s">&quot;Ravi Patel&quot;</span>
</li><li><span class="k">let</span> <span class="nv">manualDrawing</span> = <span class="nv">Line</span>(<span class="nv">elements</span>: [
</li><li>    <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">3</span>),
</li><li>    <span class="nv">Text</span>(<span class="s">&quot;Hello&quot;</span>),
</li><li>    <span class="nv">Space</span>(),
</li><li>    <span class="nv">AllCaps</span>(<span class="nv">content</span>: <span class="nv">Text</span>((<span class="nv">name</span> ?? <span class="s">&quot;World&quot;</span>) + <span class="s">&quot;!&quot;</span>)),
</li><li>    <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">2</span>),
</li><li>    ])
</li><li><span class="nv">print</span>(<span class="nv">manualDrawing</span>.<span class="nv">draw</span>())
</li><li><span class="c">// Prints &quot;***Hello RAVI PATEL!**&quot;</span>
</li></ol></div></div></div>
<p>This code works, but it’s a little awkward. The deeply nested parentheses after <code class="docutils literal notranslate"><span class="pre">AllCaps</span></code> are hard to read. The fallback logic to use “World” when <code class="docutils literal notranslate"><span class="pre">name</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code> has to be done inline using the <code class="docutils literal notranslate"><span class="pre">??</span></code> operator, which would be difficult with anything more complex. If you needed to include switches or <code class="docutils literal notranslate"><span class="pre">for</span></code> loops to build up part of the drawing, there’s no way to do that. A result builder lets you rewrite code like this so that it looks like normal Swift code.</p>
<p>To define a result builder, you write the <code class="docutils literal notranslate"><span class="pre">&#64;resultBuilder</span></code> attribute on a type declaration. For example, this code defines a result builder called <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code>, which lets you use a declarative syntax to describe a drawing:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">resultBuilder</span>
</li><li><span class="k">struct</span> <span class="nv">DrawingBuilder</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildBlock</span>(<span class="k">_</span> <span class="nv">components</span>: <span class="nc">Drawable</span>...) -&gt; <span class="nc">Drawable</span> {
</li><li>        <span class="k">return</span> <span class="nv">Line</span>(<span class="nv">elements</span>: <span class="nv">components</span>)
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li><li>        <span class="k">return</span> <span class="nv">first</span>
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li><li>        <span class="k">return</span> <span class="nv">second</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> structure defines three methods that implement parts of the result builder syntax. The <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method adds support for writing a series of lines in a block of code. It combines the components in that block into a <code class="docutils literal notranslate"><span class="pre">Line</span></code>. The <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods add support for <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code>.</p>
<p>You can apply the <code class="docutils literal notranslate"><span class="pre">&#64;DrawingBuilder</span></code> attribute to a function’s parameter, which turns a closure passed to the function into the value that the result builder creates from that closure. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">draw</span>(@<span class="nv">DrawingBuilder</span> <span class="nv">content</span>: () -&gt; <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li><li>    <span class="k">return</span> <span class="nv">content</span>()
</li><li>}
</li><li><span class="k">func</span> <span class="nv">caps</span>(@<span class="nv">DrawingBuilder</span> <span class="nv">content</span>: () -&gt; <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li><li>    <span class="k">return</span> <span class="nv">AllCaps</span>(<span class="nv">content</span>: <span class="nv">content</span>())
</li><li>}
</li><li>
</li><li><span class="k">func</span> <span class="nv">makeGreeting</span>(<span class="nv">for</span> <span class="nv">name</span>: <span class="nc">String</span>? = <span class="k">nil</span>) -&gt; <span class="nc">Drawable</span> {
</li><li>    <span class="k">let</span> <span class="nv">greeting</span> = <span class="nv">draw</span> {
</li><li>        <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">3</span>)
</li><li>        <span class="nv">Text</span>(<span class="s">&quot;Hello&quot;</span>)
</li><li>        <span class="nv">Space</span>()
</li><li>        <span class="nv">caps</span> {
</li><li>            <span class="k">if</span> <span class="k">let</span> <span class="nv">name</span> = <span class="nv">name</span> {
</li><li>                <span class="nv">Text</span>(<span class="nv">name</span> + <span class="s">&quot;!&quot;</span>)
</li><li>            } <span class="k">else</span> {
</li><li>                <span class="nv">Text</span>(<span class="s">&quot;World!&quot;</span>)
</li><li>            }
</li><li>        }
</li><li>        <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">2</span>)
</li><li>    }
</li><li>    <span class="k">return</span> <span class="nv">greeting</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">genericGreeting</span> = <span class="nv">makeGreeting</span>()
</li><li><span class="nv">print</span>(<span class="nv">genericGreeting</span>.<span class="nv">draw</span>())
</li><li><span class="c">// Prints &quot;***Hello WORLD!**&quot;</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">personalGreeting</span> = <span class="nv">makeGreeting</span>(<span class="nv">for</span>: <span class="s">&quot;Ravi Patel&quot;</span>)
</li><li><span class="nv">print</span>(<span class="nv">personalGreeting</span>.<span class="nv">draw</span>())
</li><li><span class="c">// Prints &quot;***Hello RAVI PATEL!**&quot;</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">makeGreeting(for:)</span></code> function takes a <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter and uses it to draw a personalized greeting. The <code class="docutils literal notranslate"><span class="pre">draw(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">caps(_:)</span></code> functions both take a single closure as their argument, which is marked with the <code class="docutils literal notranslate"><span class="pre">&#64;DrawingBuilder</span></code> attribute. When you call those functions, you use the special syntax that <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> defines. Swift transforms that declarative description of a drawing into a series of calls to the methods on <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> to build up the value that’s passed as the function argument. For example, Swift transforms the call to <code class="docutils literal notranslate"><span class="pre">caps(_:)</span></code> in that example into code like the following:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">capsDrawing</span> = <span class="nv">caps</span> {
</li><li>    <span class="k">let</span> <span class="nv">partialDrawing</span>: <span class="nc">Drawable</span>
</li><li>    <span class="k">if</span> <span class="k">let</span> <span class="nv">name</span> = <span class="nv">name</span> {
</li><li>        <span class="k">let</span> <span class="nv">text</span> = <span class="nv">Text</span>(<span class="nv">name</span> + <span class="s">&quot;!&quot;</span>)
</li><li>        <span class="nv">partialDrawing</span> = <span class="nv">DrawingBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">text</span>)
</li><li>    } <span class="k">else</span> {
</li><li>        <span class="k">let</span> <span class="nv">text</span> = <span class="nv">Text</span>(<span class="s">&quot;World!&quot;</span>)
</li><li>        <span class="nv">partialDrawing</span> = <span class="nv">DrawingBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nv">text</span>)
</li><li>    }
</li><li>    <span class="k">return</span> <span class="nv">partialDrawing</span>
</li><li>}
</li></ol></div></div></div>
<p>Swift transforms the <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code> block into calls to the <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods. Although you don’t call these methods in your own code, showing the result of the transformation makes it easier to see how Swift transforms your code when you use the <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> syntax.</p>
<p>To add support for writing <code class="docutils literal notranslate"><span class="pre">for</span></code> loops in the special drawing syntax, add a <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">DrawingBuilder</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildArray</span>(<span class="k">_</span> <span class="nv">components</span>: [<span class="nc">Drawable</span>]) -&gt; <span class="nc">Drawable</span> {
</li><li>        <span class="k">return</span> <span class="nv">Line</span>(<span class="nv">elements</span>: <span class="nv">components</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">manyStars</span> = <span class="nv">draw</span> {
</li><li>    <span class="nv">Text</span>(<span class="s">&quot;Stars:&quot;</span>)
</li><li>    <span class="k">for</span> <span class="nv">length</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">3</span> {
</li><li>        <span class="nv">Space</span>()
</li><li>        <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="nv">length</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>In the code above, the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop creates an array of drawings, and the <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> method turns that array into a <code class="docutils literal notranslate"><span class="pre">Line</span></code>.</p>
<p>For a complete list of how Swift transforms builder syntax into calls to the builder type’s methods, see <a class="reference internal" href="../ReferenceManual/Attributes.html#ID633"><span class="std std-ref">resultBuilder</span></a>.</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="AccessControl.html">Access Control</a></p>
        <p class="next"><a href="../ReferenceManual/AboutTheLanguageReference.html">About the Language Reference</a></p>
    </div>
    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        </p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright &copy; 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../_static/javascripts/application.js"></script>
  </body>
</html>